---
title: "Introduction to vimp"
author: "Brian D. Williamson"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Introduction to vimp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: williamson2020a
  title: Nonparametric variable importance assessment using machine learning techniques
  author:
  - family: Williamson
    given: Brian D
  - family: Gilbert
    given: Peter B
  - family: Carone
    given: Marco
  - family: Simon
    given: Noah
  publisher: Biometrics
  type: article-journal
  issued:
   year: 2020
- id: williamson2020b
  title: A unified approach for inference on algorithm-agnostic variable importance
  author:
  - family: Williamson
    given: Brian D
  - family: Gilbert
    given: Peter B
  - family: Simon
    given: Noah
  - family: Carone
    given: Marco
  publisher: arXiv
  type: article-journal
  issued:
   year: 2020
  URL: https://arxiv.org/abs/2004.03683
- id: williamson2020c
  title: A unified approach for assessing population feature importance using Shapley values
  author:
  - family: Williamson
    given: Brian D
  - family: Feng
    given: Jean
  publisher: arXiv
  type: article-journal
  issued:
   year: 2020
- id: hastie1990
  title: Generalized Additive Models
  author:
  - family: Hastie
    given: TJ
  - family: Tibshirani
    given: RJ
  #container-title: CRC Press
  volume: 43
  #URL: 'http://dx.doi.org/10.1038/nmat3283'
  #DOI: 10.1038/nmat3283
  #issue: 4
  publisher: CRC Press
  #page: 261-263
  type: book
  issued:
    year: 1990
    #month: 3
- id: vanderlaan2007
  title: Super learner
  author:
  - family: van der Laan
    given: MJ
  - family: Polley
    given: EC
  - family: Hubbard
    given: AE
  volume: 6
  publisher: Statistical Applications in Genetics and Molecular Biology
  type: article-journal
  issued:
   year: 2007
- id: harrison1978
  title: Hedonic housing prices and the demand for clean air
  author:
  - family: Harrison
    given: D
  - family: Rubinfeld
    given: DL
  volume: 5
  publisher: Journal of Environmental Economics and Management
  type: article-journal
  issued:
   year: 1978
- id: breiman2001
  title: Random forests
  author:
  - family: Breiman
    given: L
  volume: 45
  publisher: Machine Learning
  type: article-journal
  issued:
   year: 2001
- id: friedman2001
  title: "Greedy function approximation: a gradient boosting machine"
  author:
  - family: Friedman
    given: JH
  publisher: The Annals of Applied Statistics
  type: article-journal
  issued:
   year: 2001
- id: zou2005
  title: Regularization and variable selection via the elastic net
  author:
  - family: Zou
    given: H
  - family: Hastie
    given: TJ
  publisher: "Journal of the Royal Statistical Society: Series B (Statistical Methodology)"
  type: article-journal
  issued:
   year: 2005
---

```{r setup, echo = FALSE, include = FALSE}
library(knitr)
opts_knit$set(cache = FALSE, verbose = TRUE, global.par = TRUE)
```

```{r more-setup, echo = FALSE}
par(mar = c(5, 12, 4, 2) + 0.1)
```

## Introduction

`vimp` is a package that computes nonparametric estimates of variable importance. The package supports flexible estimation of variable importance based on the difference in nonparametric $R^2$, classification accuracy, and area under the receiver operating characteristic curve (AUC). These quantities are all nonparametric generalizations of the usual measures in simple parametric models (e.g., linear models). For more details, see the accompanying manuscripts [@williamson2020a] and [@williamson2020b].

Variable importance estimates may be computed quickly, depending on the techniques used to estimate the underlying conditional means --- if these techniques are slow, then the variable importance procedure will be slow.

The code can handle arbitrary dimensions of features, and may be used to estimate the importance of any single feature or group of features for predicting the outcome. The package also includes functions for cross-validated importance.

The author and maintainer of the `vimp` package is [Brian Williamson](https://bdwilliamson.github.io/).

## Installation

A stable version of the package may be downloaded and installed from CRAN. Type the following command in your R console to install the stable version of `vimp`:
```{r install-vimp, eval = FALSE}
install.packages("vimp")
```

A development version of the package may be downloaded and installed from GitHub using the `devtools` package. Type the following command in your R console to install the development version of `vimp`:

```{r devtools-install-vimp, eval = FALSE}
# only run if you don't have devtools
# previously installed
# install.packages("devtools")
devtools::install_github("bdwilliamson/vimp")
```

## Quick Start

This section should serve as a quick guide to using the `vimp` package --- we will cover the main functions for estimating $R^2$-based variable importance using a simulated data example. More details are given in the next section.

First, load the `vimp` package:
```{r load-vimp}
library("vimp")
```

Next, create some data:
```{r gen-data}
## -------------------------------------------------------------
## problem setup
## -------------------------------------------------------------
## set up the data
n <- 1000
p <- 2
s <- 1 # desire importance for X_1
x <- data.frame(replicate(p, runif(n, -1, 1)))
y <- (x[,1])^2*(x[,1]+7/5) + (25/9)*(x[,2])^2 + rnorm(n, 0, 1)
## set up folds for hypothesis testing
folds <- sample(rep(seq_len(2), length = length(y)))
```

This creates a matrix of covariates `x` with two columns, a vector `y` of normally-distributed outcome values, and a set of folds for a sample of `n = 100` study participants.

The workhorse function of `vimp`, for $R^2$-based variable importance, is `vimp_rsquared`. The basic arguments are

* Y: the outcome (in this example, `y`)
* X: the covariates (in this example, `x`)
* indx: the covariate(s) of interest for evaluating importance (here, either 1 or 2)
* run_regression: a logical value telling `vimp_rsquared` whether or not to run a regression of Y on X
* SL.library: a "library" of learners to pass to the function `SuperLearner`, if `run_regression = TRUE`
* folds: a set of folds for hypothesis testing

This second-to-last argument, `SL.library`, determines the estimators you want to use for the conditional mean of Y given X. Estimates of variable importance rely on good estimators of the conditional mean, so we suggest using flexible estimators and model stacking to do so. One option for this is the `SuperLearner` package; load that package using

```{r learner-lib-small}
library("SuperLearner")
## load specific algorithms
library("gam")
library("xgboost")
SL.xgboost1 <- function(..., max_depth = 1, ntree = 500, shrinkage = 0.1){
  SL.xgboost(..., max_depth = max_depth, ntree = ntree, shrinkage = shrinkage)
}
```

The code
```{r est-1}
est_1 <- vimp_rsquared(Y = y, X = x, indx = 1, run_regression = TRUE,
SL.library = c("SL.xgboost1", "SL.mean"), V = 3, env = environment(), folds = folds)
```

uses the Super Learner to fit the required regression functions, and computes an estimate of variable importance for the importance of $X_1$. We can visualize the estimate, standard error, and confidence interval by printing or typing the object name:
```{r print-est-1}
est_1
print(est_1)
```

This output shows that we have estimated the importance of $X_1$ to be `r round(est_1$est, 3)`, with a 95% confidence interval of `r paste0("[", round(est_1$ci[,1], 3), ", ", round(est_1$ci[, 2], 3), "]")`.

## Detailed guide

In this section, we provide a fuller example of estimating $R^2$-based variable importance in the context of the South African heart disease study data [@hastie2011].

Often when working with data we attempt to estimate the conditional mean of the outcome $Y$ given features $X$, defined as $\mu_P(x) = E_P(Y \mid X = x)$.

There are many tools for estimating this conditional mean. We might choose a classical parametric tool such as linear regression. We might also want to be model-agnostic and use a more nonparametric approach to estimate the conditional mean. However,

- This involves using some nonparametric smoothing technique, which requires: (1) choosing a technique, and (2) selecting tuning parameters
- Naive optimal tuning balances out the bias and variance of the smoothing estimator. Is this the correct trade-off for estimating the conditional mean?

Once we have a good estimate of the conditional mean, it is often of scientific interest to understand which features contribute the most to the variation in $\mu_P$. Specifically, we might consider \[\mu_{P, s}(x) = E_P(Y \mid X_{(-s)} = x_{(-s)}),\] where for a vector $v$ and a set of indices $s$, $v_{-(s)}$ denotes the elements of $v$ with index not in $s$. By comparing $\mu_{P, s}$ to $\mu_P$ we can evaluate the importance of the $s$th element (or group of elements).

Assume that our data are generated according to the mechanism $P_0$. We define the population $R^2$ value of a given regression function $\mu$ as $R^2(\mu, P_0) = 1 - \frac{E_{P_0}\{Y - \mu(X)\}^2}{var_{P_0}(Y)}$, where the numerator of this expression is the population mean squared error and the denominator is the population variance. We can then define a nonparametric measure of variable importance, \[\psi_{0, s} = R^2(\mu_{P_0}, P_0) - R^2(\mu_{P_0,s}, P_0),\] which is the proportion of the variability in the outcome explained by including $X_j$ in our chosen estimation technique.

This document introduces you to the basic tools in `vimp` and how to apply them to a dataset. I will explore the two different ways of obtaining variable estimates using `vimp`:

1. You only specify a *library* of candidate estimators for the conditional means $\mu_{P_0}$ and $\mu_{P_0, s}$; you allow `vimp` to obtain the optimal estimates of these quantities using the `SuperLearner` [@vanderlaan2007], and use these estimates to obtain variable importance estimates
2. You have a favorite estimator for the conditional means; you simply want `vimp` to obtain variable importance estimates using this estimator

### A look at the South African heart disease study data

Throughout this document I will use the South African heart disease study data [@hastie2011], freely available from the [Elements of Statistical Learning website](https://web.stanford.edu/~hastie/ElemStatLearn/datasets/SAheart.data). Information about these data is available [here](https://web.stanford.edu/~hastie/ElemStatLearn/datasets/SAheart.info.txt).

```{r load-heart-data}
## read in the data from the Elements website
library("RCurl")
heart_data <- read.csv(text = getURL("http://web.stanford.edu/~hastie/ElemStatLearn/datasets/SAheart.data"), header = TRUE, stringsAsFactors = FALSE)
## minor data cleaning
heart <- heart_data[, 2:dim(heart_data)[2]]
heart$famhist <- ifelse(heart$famhist == "Present", 1, 0)
## folds
heart_folds <- sample(rep(seq_len(2), length = dim(heart)[1]))
```

In addition to the indicator of myocardial infarction `chd`, the outcome of interest, there are measurements on two groups of variables. First are behavioral features: cumulative tobacco consumption, current alcohol consumption, and type A behavior (a behavioral pattern linked to stress). Second are biological features: systolic blood pressure, low-density lipoprotein (LDL) cholesterol, adiposity (similar to body mass index), family history of heart disease, obesity, and age.

Since there are nine features and two groups, it is of interest to determine variable importance both for the nine individual features separately and for the two groups of features.

### A first approach: linear regression
Suppose that I believe that a linear model truly describes the relationship between the outcome and the covariates in these data. In that case, I would be justified in only fitting a linear regression to estimate the conditional means; this means that in my importance analysis, I should also use only linear regression. This is achieved by the following:

```{r est-heart-regressions-lm}
## estimate the full conditional mean using linear regression
full_mod <- lm(chd ~ ., data = subset(heart, heart_folds == 1))
full_fit <- predict(full_mod)

## estimate the reduced conditional means for each of the individual variables
X <- as.matrix(heart[, -dim(heart)[2]])[heart_folds == 2, ] # remove the outcome for the predictor matrix
red_mod_sbp <- lm(full_fit ~ X[,-1])
red_fit_sbp <- predict(red_mod_sbp)
red_mod_tob <- lm(full_fit ~ X[,-2])
red_fit_tob <- predict(red_mod_tob)
red_mod_ldl <- lm(full_fit ~ X[,-3])
red_fit_ldl <- predict(red_mod_ldl)
red_mod_adi <- lm(full_fit ~ X[,-4])
red_fit_adi <- predict(red_mod_adi)
red_mod_fam <- lm(full_fit ~ X[,-5])
red_fit_fam <- predict(red_mod_fam)
red_mod_tpa <- lm(full_fit ~ X[, -6])
red_fit_tpa <- predict(red_mod_tpa)
red_mod_obe <- lm(full_fit ~ X[,-7])
red_fit_obe <- predict(red_mod_obe)
red_mod_alc <- lm(full_fit ~ X[, -8])
red_fit_alc <- predict(red_mod_alc)
red_mod_age <- lm(full_fit ~ X[,-9])
red_fit_age <- predict(red_mod_age)

## load the library
library("vimp")
library("dplyr")

## plug these into vim
lm_vim_sbp <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_sbp, indx = 1, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_tob <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_tob, indx = 2, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_ldl <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_ldl, indx = 3, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_adi <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_adi, indx = 4, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_fam <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_fam, indx = 5, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_tpa <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_tpa, indx = 6, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_obe <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_obe, indx = 7, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_alc <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_alc, indx = 8, run_regression = FALSE, type = "r_squared", folds = heart_folds)
lm_vim_age <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit_age, indx = 9, run_regression = FALSE, type = "r_squared", folds = heart_folds)

## make a table with the estimates using the merge_vim() function
lm_mat <- merge_vim(lm_vim_sbp, lm_vim_tob, lm_vim_ldl, lm_vim_adi,
                lm_vim_fam, lm_vim_tpa, lm_vim_obe, lm_vim_alc, lm_vim_age)
## print out the matrix
lm_mat
```

### Building a library of learners

In general, we don't believe that a linear model truly holds. Thinking about potential model misspecification leads us to consider other algorithms. Suppose that I prefer to use generalized additive models [@hastie1990] to estimate $\mu_{P_0}$ and $\mu_{P_0, s}$, so I am planning on using the `gam` package. Suppose that you prefer to use the elastic net [@zou2005], and are planning to use the `glmnet` package.

The choice of either method is somewhat subjective, and I also will have to use a technique like cross-validation to determine an optimal tuning parameter in each case. It is also possible that neither additive models nor the elastic net will do a good job estimating the true conditional means!

This motivates using `SuperLearner` to allow the data to determine the optimal combination of *base learners* from a *library* that I define. These base learners are a combination of different methods (e.g., generalized additive models and elastic net) and instances of the same method with different tuning parameter values (e.g., additive models with 3 and 4 degrees of freedom). The Super Learner is an example of model stacking, or model aggregation --- these approaches use a data-adaptive combination of base learners to make predictions.

For instance, my library could include the elastic net, random forests [@breiman2001], and gradient boosted trees [@friedman2001] as follows:

```{r full-learner-lib}
## load the library
library(SuperLearner)

## create a function for boosted stumps
SL.gbm.1 <- function(..., interaction.depth = 1) SL.gbm(..., interaction.depth = interaction.depth)

## create GAMs with different degrees of freedom
SL.gam.3 <- function(..., deg.gam = 3) SL.gam(..., deg.gam = deg.gam)
SL.gam.4 <- function(..., deg.gam = 4) SL.gam(..., deg.gam = deg.gam)
SL.gam.5 <- function(..., deg.gam = 5) SL.gam(..., deg.gam = deg.gam)

## add more levels of alpha for glmnet
create.SL.glmnet <- function(alpha = c(0.25, 0.5, 0.75)) {
  for (mm in seq(length(alpha))) {
    eval(parse(file = "", text = paste('SL.glmnet.', alpha[mm], '<- function(..., alpha = ', alpha[mm], ') SL.glmnet(..., alpha = alpha)', sep = '')), envir = .GlobalEnv)
  }
  invisible(TRUE)
}
create.SL.glmnet()

## add tuning parameters for randomForest
create.SL.randomForest <- function(tune = list(mtry = c(1, 5, 7), nodesize = c(1, 5, 10))) {
  tuneGrid <- expand.grid(tune, stringsAsFactors = FALSE)
  for (mm in seq(nrow(tuneGrid))) {
    eval(parse(file = "", text = paste("SL.randomForest.", mm, "<- function(..., mtry = ", tuneGrid[mm, 1], ", nodesize = ", tuneGrid[mm, 2], ") SL.randomForest(..., mtry = mtry, nodesize = nodesize)", sep = "")), envir = .GlobalEnv)
  }
  invisible(TRUE)
}
create.SL.randomForest()

## create the library
learners <- c("SL.glmnet", "SL.glmnet.0.25", "SL.glmnet.0.5", "SL.glmnet.0.75",
              "SL.randomForest", "SL.randomForest.1", "SL.randomForest.2", "SL.randomForest.3",
              "SL.randomForest.4", "SL.randomForest.5", "SL.randomForest.6", "SL.randomForest.7",
              "SL.randomForest.8", "SL.randomForest.9",
              "SL.gbm.1")
```

Now that I have created the library of learners, I can move on to estimating variable importance.

### Estimating variable importance for a single variable

The main function for R-squared-based variable importance in the `vimp` package is the `vimp_rsquared()` function. There are five main arguments to `vimp_rsquared()`:

- `Y`, the outcome
- `f1` and `f2`, the fitted values from a sequential regression procedure; or `X`, the covariates
- `indx`, which determines the feature I want to estimate variable importance for
- `run_regression`, which determines whether or not the sequential regression procedure is run on `Y` and `X`
- `V`, the number of cross-validation folds to use for computing variable importance

There are two ways to compute importance:

1. Supply outcome `Y`, covariates `X`, and a library of learners (e.g., `learners` above) with `run_regression = TRUE` and specified `V`
2. Supply outcome `Y` and fitted values for cross-fit estimates of $\mu_{P_0}$ and $\mu_{P_0, s}$ with `run_regression = FALSE` and list of folds `folds`

I will illustrate each of these choices in order below, but in practice I use (1), because there is less overhead prior to obtaining variable importance estimates.

Suppose that the first feature that I want to estimate variable importance for is family history of heart disease, `fam`. Since this is the first feature, say I choose (1) above. Then supplying `vimp_rsquared()` with

- `Y = heart$chd`
- `X = X`
- `indx = 5`
- `run_regression = TRUE`
- `V = 5`

means that:

- I want to use `SuperLearner()` to estimate the conditional means $\mu_{P_0}$ and $\mu_{P_0,s}$
- I want to estimate variable importance for the fifth column of the South African heart disease study covariates, which is `fam`
- I want to use five-fold cross-validation to estimate importance

The call to `vimp_rsquared()` looks like this:
```{r vimp-with-sl-1, eval = FALSE}
## load the library
library("vimp")

## now estimate variable importance
vimp_rsquared(Y = heart$chd, X = X,
    indx = 5, run_regression = TRUE, SL.library = learners, V = 5)
```

While this is the preferred method for estimating variable importance, using a large library of learners may cause the function to take time to run. Usually this is okay --- in general, you took a long time to collect the data, so letting an algorithm run for a few hours should not be an issue.

However, for the sake of illustration, I can estimate varibable importance for family history only using only one base learner as follows:
```{r vimp-with-sl-fam, message = FALSE}
## load the library
library("vimp")

## new learners library, with only one learner for illustration only
SL.xgboost1 <- function(..., max_depth = 1, ntree = 500, shrinkage = 0.1){
  SL.xgboost(..., max_depth = max_depth, ntree = ntree, shrinkage = shrinkage)
}
learners.2 <- c("SL.xgboost1")

## now estimate variable importance
fam_vim <- vim(Y = heart$chd, X = heart[, -dim(heart)[2]], indx = 5, run_regression = TRUE, SL.library = learners.2, na.rm = TRUE, env = environment(), type = "r_squared", folds = heart_folds)
```

This code takes approximately 5 seconds to run on a (not very fast) PC. Under the hood, `vim()` with `run_regression = TRUE` fits the `SuperLearner()` function with the specified library, and then returns fitted values and variable importance estimates. This is most suitable for estimating variable importance for the first feature on a given dataset. I can display these estimates:

```{r print-fam-vim}
fam_vim
```

The object returned by `vimp_rsquared()` also contains fitted values from using `SuperLearner()`; I access these using `$full_fit` and `$red_fit`. For example,

```{r look-at-fam-ests}
head(fam_vim$full_fit)
head(fam_vim$red_fit)
```

I said earlier that I want to obtain estimates of all individual features in these data, so let's choose type A behavior (`tpa`) next. Now that I have estimated variable importance for family history, the `full_fit` object contains our estimate of $\mu_{P_0}$. Since I have spent the time to estimate this using `SuperLearner()`, there is no reason to estimate this function again. This leads me to choose (2) above for estimating the importance of type A behavior, since I have already estimated variable importance on one feature in this dataset. Using the small learners library (again only for illustration) yields

```{r typea-vim, message = FALSE}
## specify that full_fit doesn't change
full_fit <- fam_vim$full_fit

## estimate variable importance for the average number of rooms
reduced_fit <- SuperLearner::SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(6, dim(heart)[2]), drop = FALSE], SL.library = learners.2)
red_fit <- predict(reduced_fit)$pred
tpa_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = red_fit, indx = 6, run_regression = FALSE, type = "r_squared", folds = heart_folds)

tpa_vim
```

This takes approximately 5 seconds --- now rather than estimating both conditional means, I am only estimating one.

If I choose (2), then I have to use a single method from the library, or call `SuperLearner()` myself, prior to estimating variable importance. Then `vim()` returns variable importance estimates based on these fitted values. For example, let's estimate variable importance for current alcohol consumption using this approach.

```{r alc-vim}
## set up the data, removing the columns for alcohol use and chd
x <- heart[, -c(8, dim(heart)[2])]

## fit an xgboost model using SuperLearner
reduced_mod <- SuperLearner(Y = full_fit, X = x[heart_folds == 2, ], SL.library = learners.2)
reduced_fit <- predict(reduced_mod)$pred
## this takes 2 seconds

## estimate variable importance
alc_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_fit, indx = 8, run_regression = FALSE, type = "r_squared", folds = heart_folds)
```

I can obtain estimates for the remaining individual features in the same way (again using only two base learners for illustration):
```{r heart-sl}
reduced_sbp <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(1, dim(heart)[2])], SL.library = learners.2))$pred
sbp_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_sbp,
                indx = 1, run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_tob <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(2, dim(heart)[2])], SL.library = learners.2))$pred
tob_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_tob,
                indx = 2, run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_ldl <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(3, dim(heart)[2])], SL.library = learners.2))$pred
ldl_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_ldl,
                indx = 3, run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_adi <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(4, dim(heart)[2])], SL.library = learners.2))$pred
adi_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_adi,
                indx = 4, run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_obe <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(7, dim(heart)[2])], SL.library = learners.2))$pred
obe_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_obe,
                indx = 7, run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_age <- predict(SuperLearner(Y = full_fit, X = heart[heart_folds == 2, -c(9, dim(heart)[2])], SL.library = learners.2))$pred
age_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_age,
                indx = 9, run_regression = FALSE, type = "r_squared", folds = heart_folds)
```

Now that I have estimates of each of individual feature's variable importance, I can view them all simultaneously by plotting:
```{r heart-vim, fig.width = 8.5, fig.height = 8}
library("dplyr")
library("tibble")
library("ggplot2")
library("cowplot")
theme_set(theme_cowplot())
library("forcats")
## combine the objects together
ests <- merge_vim(sbp_vim, tob_vim, ldl_vim, adi_vim,
                fam_vim, tpa_vim, obe_vim, alc_vim, age_vim)

get_nm <- function(s) {
  if (s == 1) {
    return("Sys. blood press.")
  } else if (s == 2) {
    return("Tobacco consump.")
  } else if (s == 3) {
    return("LDL cholesterol")
  } else if (s == 4) {
    return("Adiposity")
  } else if (s == 5) {
    return("Family history")
  } else if (s == 6) {
    return("Type A behavior")
  } else if (s == 7) {
    return("Obesity")
  } else if (s == 8) {
    return("Alcohol consump.")
  } else if (s == 9) {
    return("Age")
  }
}
get_nms <- function(ests) {
  return(apply(matrix(as.numeric(ests$s)), 1, get_nm))
}

## plot
ests$mat %>%
  arrange(desc(est)) %>%
  mutate(ord_group = forcats::fct_reorder(get_nms(ests$mat), est)) %>%
  ggplot(aes(x = est, y = ord_group)) +
  geom_point() +
  geom_errorbarh(aes(xmin = cil, xmax = ciu)) +
  xlab(expression(paste("Variable importance estimates: ", R^2, sep = ""))) +
  ylab("") +
  ggtitle("Variable importance estimates for individual features in the South African heart disease study data")
```

## Estimating variable importance for a group of variables

Now that I have estimated variable importance for each of the individual features, I can estimate variable importance for each of the groups that I mentioned above: biological and behavioral features.

The only difference between estimating variable importance for a group of features rather than an individual feature is that now I specify a vector for `s`; I can use any of the options listed in the previous section to compute these estimates.

```{r heart-group-vim, fig.width = 8.5, fig.height = 8}
## get the estimates
reduced_behav <- predict(SuperLearner(Y = heart$chd[heart_folds == 2], X = heart[heart_folds == 2, -c(2, 6, 8, dim(heart)[2])], SL.library = learners.2))$pred
behav_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_behav, indx = c(2, 6, 8), run_regression = FALSE, type = "r_squared", folds = heart_folds)

reduced_bios <- predict(SuperLearner(Y = heart$chd[heart_folds == 2], X = heart[heart_folds == 2, -c(1, 3, 4, 5, 7, 9, dim(heart)[2])], SL.library = learners.2))$pred
bios_vim <- vim(Y = heart$chd, f1 = full_fit, f2 = reduced_bios, indx = c(1, 3, 4, 5, 7, 9), run_regression = FALSE, type = "r_squared", folds = heart_folds)

## combine and plot
groups <- merge_vim(behav_vim, bios_vim)
nms.2 <- c("Behavioral features", "Biological features")
nms_grp <- function(s) {
  if (s == "1,3,4,5,7,9") {
    return("Biological features")
  } else {
    return("Behavioral features")
  }
}
get_nms_grp <- function(ests) {
  return(unlist(lapply(as.list(ests$s), function(x) nms_grp(x))))
}
groups$mat %>%
  arrange(desc(est)) %>%
  mutate(ord_group = forcats::fct_reorder(get_nms_grp(groups$mat), est)) %>%
  ggplot(aes(x = est, y = ord_group)) +
  geom_point() +
  geom_errorbarh(aes(xmin = cil, xmax = ciu)) +
  xlab(expression(paste("Variable importance estimates: ", R^2, sep = ""))) +
  ylab("") +
  ggtitle("Variable importance estimates for groups of features in the South African heart disease study data")
```

## References
